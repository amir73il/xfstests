#! /bin/bash
# SPDX-License-Identifier: GPL-2.0

#
# FSQA Test No. generic/019
#
# Run fsstress and fio(dio/aio and mmap) and simulate disk failure
# check filesystem consistency at the end.
#
seq=`basename $0`
seqres=$RESULT_DIR/$seq
echo "QA output created by $seq"

here=`pwd`
tmp=/tmp/$$
fio_config=$tmp.fio
status=1	# failure is the default!

# get standard environment, filters and checks
. ./common/rc
. ./common/filter
_supported_fs generic
_require_scratch_nocheck
_disable_dmesg_check
BLK_DEV=`_scratch_base_device`
_require_block_device $BLK_DEV
_require_fail_make_request

SYSFS_BDEV=`_sysfs_dev $BLK_DEV`

allow_fail_make_request()
{
    echo "Allow global fail_make_request feature"
    echo 100 > $DEBUGFS_MNT/fail_make_request/probability
    echo 9999999 > $DEBUGFS_MNT/fail_make_request/times
    echo 0 >  /sys/kernel/debug/fail_make_request/verbose
}

disallow_fail_make_request()
{
    echo "Disallow global fail_make_request feature"
    echo 0 > $DEBUGFS_MNT/fail_make_request/probability
    echo 0 > $DEBUGFS_MNT/fail_make_request/times
}

start_fail_scratch_dev()
{
    echo "Force SCRATCH_DEV device failure"
    echo " echo 1 > $SYSFS_BDEV/make-it-fail" >> $seqres.full
    echo 1 > $SYSFS_BDEV/make-it-fail
}

stop_fail_scratch_dev()
{
    echo "Make SCRATCH_DEV device operable again"
    echo " echo 0 > $SYSFS_BDEV/make-it-fail" >> $seqres.full
    echo 0 > $SYSFS_BDEV/make-it-fail
}

_cleanup()
{
    disallow_fail_make_request
    rm -f $tmp.*
}
trap "_cleanup; exit \$status" 0 1 2 3 15

RUN_TIME=$((20+10*$TIME_FACTOR))
NUM_JOBS=$((4*LOAD_FACTOR))
BLK_DEV_SIZE=`blockdev --getsz $BLK_DEV`
FILE_SIZE=$((BLK_DEV_SIZE * 512))

_workout()
{
	dd if=/dev/zero of=$SCRATCH_MNT/touch_failed_filesystem count=1 bs=4k >> $seqres.full 2>&1
	start_fail_scratch_dev
	# After device turns in to failed state filesystem may yet not know about
	# that so buffered write(2) may succeed, but any integrity operations
	# such as (sync, fsync, fdatasync, direct-io) should fail.
	sync $SCRATCH_MNT/touch_failed_filesystem >> $seqres.full 2>&1 && \
	    _fail "failed: still able to perform integrity fsync on $SCRATCH_MNT"

	# We expect that broken FS still can be umounted
	run_check _scratch_unmount
	# Once filesystem was umounted no one is able to write to block device
	# It is now safe to bring device back to normal state
	stop_fail_scratch_dev

	# In order to check that filesystem is able to recover journal on mount(2)
	# perform mount/umount, after that all errors should be fixed
	#_scratch_mount
	#run_check _scratch_unmount
}

# real QA test starts here

rm -f $seqres.full
_scratch_mkfs >> $seqres.full 2>&1 || _fail "mkfs failed"
_scratch_mount # -o "volatile"
allow_fail_make_request
_workout
status=$?
exit
